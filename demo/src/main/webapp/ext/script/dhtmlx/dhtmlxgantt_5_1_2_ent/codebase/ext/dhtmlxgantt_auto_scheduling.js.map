{"version":3,"sources":["webpack:///dhtmlxgantt_auto_scheduling.js","webpack:///webpack/bootstrap c4a39cba6e1e70e8474e","webpack:///./sources/core/links_common.js","webpack:///./sources/ext/auto_scheduling.js","webpack:///./sources/utils/helpers.js"],"names":["Gantt","plugin","gantt","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_get_linked_task","link","getTarget","task","taskId","target","source","isTaskExists","getTask","role","assert","id","_get_link_target","_get_link_source","_formatLink","relations","this","isChildOf","isSummaryTask","from","_getImplicitLinks","respectTargetOffset","config","auto_scheduling_move_projects","targetDates","getSubtaskDates","start_date","end_date","to","$target","length","getState","drag_id","calculateDuration","fromTask","j","toTask","lag","subtaskLink","type","push","_convertToFinishToStartLink","_isAutoSchedulable","auto_scheduling","parent","selectOffset","eachTask","_getDirectDependencies","selectSuccessors","links","successors","linksIds","$source","getLink","concat","_getInheritedDependencies","stop","inheritedRelations","eachParent","apply","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","_getSuccessors","_getPredecessors","sourceTask","targetTask","res","finish_to_start","preferredStart","additionalLag","start_to_start","duration","finish_to_finish","start_to_finish","auto_scheduling_descendant_links","auto_scheduling_initial","auto_scheduling_strict","helpers","_autoSchedulingGraph","getVertices","ids","forEach","rel","vertices","sort","a","b","getGlobalTaskIndex","topologicalSort","edges","hash","$incoming","successor","S","filter","v","L","pop","node","tarjanStronglyConnectedComponents","strongConnect","vertexId","previousLink","getVertex","index","lowLink","connectedEdges","onStack","edge","w","undefined","Math","min","connectedComponent","tasks","connectedComponents","verticesHash","_autoSchedulingPath","getKey","join","getVirtualRoot","mixin","root_id","types","project","$virtual","filterDuplicates","keys","key","splice","getLinkedTasks","includePredecessors","startIds","visited","_getLinkedTasks","rootTask","visitedTasks","rootObj","chainRelations","children","getChildren","findLoops","cycles","graph","component","_autoSchedulingDateResolver","isFirstSmaller","small","big","valueOf","_hasDuration","isSmallerOrDefault","smallDate","bigDate","resolveRelationDate","getEndDate","minStart","linkId","defaultStart","relation","constraintDate","getConstraintDate","getClosestWorkTime","date","dir","predecessorEnd","successorStart","calculateEndDate","_autoSchedulingPlanner","generatePlan","getPredecessorEndDate","plan","plansHash","orderedIds","predecessorRelations","arrayMap","dateResolver","result","currentId","isLinkExists","predecessor","callEvent","applyProjectPlan","projectPlan","updateTasks","newDate","_autoSchedulingPreferredDates","startTask","Date","_autoSchedule","updateCallback","_autoscheduling_in_progress","path","updatedTasks","planner","autoSchedule","inclusive","_finalizeAutoSchedulingChanges","resetTime","batchUpdate","start","end","resetProjectDates","payload","updateTask","isCircularLink","_getConnectedGroup","manager","allRelations","findCycles","_attachAutoSchedulingHandlers","resetToStartLinksLags","skipped","originalLink","presentLinks","updatedLinks","_autoScheduleAfterLinkChange","attachEvent","predecessors","_preventCircularLink","_preventDescendantLink","_datesNotEqual","dateA","dateB","taskA","taskB","_notEqualTaskDates","task1","task2","milestone","movedTask","mode","_autoScheduleAfterDND","newTask","_lightBoxChangesHandler","oldTask","_autoschedule_lightbox_id","_lightBoxSaveHandler","getSecondsInUnit","unit","units","hour","arr","callback","workArray","slice","resArray","second","minute","day","week","month","quarter","year"],"mappings":"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","file":"dhtmlxgantt_auto_scheduling.js","sourcesContent":["/*!\n * @license\n * \n * dhtmlxGantt v.5.1.2 Professional\n * This software is covered by DHTMLX Enterprise License. Usage without proper license is prohibited.\n * \n * (c) Dinamenta, UAB.\n * \n */\nGantt.plugin(function(gantt){\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(gantt) {\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\t\tvar role = getTarget ? \"target\" : \"source\";\n\t\tgantt.assert(task, \"Link \" + role + \" not found. Task id=\" + taskId + \", link id=\" + link.id);\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\n\tgantt._formatLink = function (link) {\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))) {\n\t\t\treturn relations;\n\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t});\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0; i < from.length; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0; j < to.length; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target));\n\t\t\t}\n\t\t}\n\n\t\treturn relations;\n\t};\n\ngantt._isAutoSchedulable = function(task){\n\treturn task.auto_scheduling !== false;\n};\n\ngantt._getImplicitLinks = function(link, parent, selectOffset){\n\tvar relations = [];\n\tif(this.isSummaryTask(parent)){\n\t\tthis.eachTask(function(c){\n\t\t\tif(!this.isSummaryTask(c))\n\t\t\t\trelations.push({task: c.id, lag: selectOffset(c)});\n\t\t}, parent.id);\n\t}else{\n\t\trelations.push({task:parent.id, lag: 0});\n\t}\n\n\t\treturn relations;\n\t};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\tfor(var i = 0; i < linksIds.length; i++){\n\t\tvar link = this.getLink(linksIds[i]);\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\tvar target = this.getTask(link.target);\n\t\t\tif(this._isAutoSchedulable(target)){\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t}\n\t\t}\n\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\t\tvar successors = [];\n\tvar stop = false;\n\tvar inheritedRelations = [];\n\tif(this.isTaskExists(task.id)){\n\t\tthis.eachParent(function(parent){\n\t\t\tif(stop)\n\t\t\t\treturn;\n\n\t\t\tif(this.isSummaryTask(parent)){\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\n\t\t\t\t\tstop = true;\n\t\t\t\t}else{\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, this._getDirectDependencies(parent, selectSuccessors));\n\t\t\t\t}\n\t\t\t}\n\t\t}, task.id, this);\n\n\t\t\tfor (var i = 0; i < inheritedRelations.length; i++) {\n\n\t\t\t\tvar relProperty = selectSuccessors ? inheritedRelations[i].source : inheritedRelations[i].target;\n\n\t\t\t\tif (relProperty == task.id) {\n\t\t\t\t\tsuccessors.push(inheritedRelations[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\n\tgantt._getSuccessors = function (task) {\n\t\treturn this._getDirectSuccessors(task).concat(this._getInheritedSuccessors(task));\n\t};\n\n\tgantt._getPredecessors = function (task) {\n\t\treturn this._getDirectPredecessors(task).concat(this._getInheritedPredecessors(task));\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\treturn res;\n\t};\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(3);\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(1)(gantt);\n\ngantt.config.auto_scheduling = false;\ngantt.config.auto_scheduling_descendant_links = false;\ngantt.config.auto_scheduling_initial = true;\ngantt.config.auto_scheduling_strict = false;\ngantt.config.auto_scheduling_move_projects = true;\n\n(function(){\n\nvar helpers = __webpack_require__(4);\n\n\ngantt._autoSchedulingGraph = {\n\tgetVertices: function(relations){\n\t\tvar ids = {};\n\n\t\thelpers.forEach(relations, function(rel){\n\t\t\tids[rel.target] = rel.target;\n\t\t\tids[rel.source] = rel.source;\n\t\t});\n\n\t\tvar vertices = [];\n\t\tfor(var i in ids){\n\t\t\tvertices.push(ids[i]);\n\t\t}\n\n\t\treturn vertices.sort(function(a, b){ return gantt.getGlobalTaskIndex(a) - gantt.getGlobalTaskIndex(b);});\n\t},\n\ttopologicalSort: function(edges){\n\t\tvar vertices = this.getVertices(edges);\n\t\tvar hash = {};\n\n\t\tfor(var i = 0; i < vertices.length; i ++){\n\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\n\t\t}\n\n\t\tfor(var i = 0; i < edges.length; i++){\n\t\t\tvar successor = hash[edges[i].target];\n\t\t\tsuccessor.$target.push(i);\n\t\t\tsuccessor.$incoming = successor.$target.length;\n\t\t\thash[edges[i].source].$source.push(i);\n\n\t\t}\n\n\t\t// topological sort, Kahn's algorithm\n\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\n\n\t\tvar L = [];\n\n\t\twhile(S.length){\n\t\t\tvar n = S.pop();\n\n\t\t\tL.push(n);\n\n\t\t\tvar node = hash[n];\n\n\t\t\tfor(var i = 0; i < node.$source.length; i++){\n\t\t\t\tvar m = hash[edges[node.$source[i]].target];\n\t\t\t\tm.$incoming--;\n\t\t\t\tif(!m.$incoming){\n\t\t\t\t\tS.push(m.id);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn L;\n\n\t},\n\ttarjanStronglyConnectedComponents: function(vertices, edges){\n\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\t\tvar verticesHash = {};\n\n\t\tvar index = 0;\n\t\tvar S = [];\n\t\tvar connectedEdges = [];\n\t\tvar connectedComponents = [];\n\n\t\thelpers.forEach(vertices, function(vertexId){\n\t\t\tvar vertex = getVertex(vertexId);\n\t\t\tif(vertex.index === undefined){\n\t\t\t\tstrongConnect(vertexId);\n\t\t\t}\n\t\t});\n\n\t\tfunction strongConnect(vertexId, previousLink){\n\t\t\tvar v = getVertex(vertexId);\n\t\t\tv.index = index;\n\t\t\tv.lowLink = index;\n\t\t\tindex++;\n\n\t\t\tif(previousLink){\n\t\t\t\tconnectedEdges.push(previousLink);\n\t\t\t}\n\n\t\t\tS.push(v);\n\t\t\tv.onStack = true;\n\n\t\t\t// Consider successors of v\n\t\t\thelpers.forEach(edges, function(edge){\n\t\t\t\tif(edge.source != vertexId) return;\n\n\t\t\t\tvar v = getVertex(edge.source);\n\t\t\t\tvar w = getVertex(edge.target);\n\t\t\t\tif(w.index === undefined){\n\t\t\t\t\t// Successor w has not yet been visited; recurse on it\n\t\t\t\t\tstrongConnect(edge.target, edge);\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\n\t\t\t\t}else if(w.onStack){\n\t\t\t\t\t// Successor w is in stack S and hence in the current SCC\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\n\t\t\t\t\tconnectedEdges.push(edge);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t// If v is a root node, pop the stack and generate an SCC\n\t\t\tif(v.lowLink == v.index){\n\t\t\t\tvar connectedComponent = {tasks: [], links:[]};\n\t\t\t\tvar w;\n\t\t\t\tdo{\n\t\t\t\t\tvar rel = connectedEdges.pop();\n\t\t\t\t\tw = S.pop();\n\t\t\t\t\tw.onStack = false;\n\t\t\t\t\tconnectedComponent.tasks.push(w.id);\n\t\t\t\t\tif(rel){\n\t\t\t\t\t\tconnectedComponent.links.push(rel.id);\n\t\t\t\t\t}\n\t\t\t\t}while(w.id != v.id);\n\t\t\t\tconnectedComponents.push(connectedComponent);\n\t\t\t}\n\n\t\t}\n\n\t\treturn connectedComponents;\n\n\t\tfunction getVertex(id){\n\t\t\tif(!verticesHash[id]){\n\t\t\t\tverticesHash[id] = {id: id};\n\t\t\t}\n\n\t\t\treturn verticesHash[id];\n\t\t}\n\n\t}\n\n};\n\ngantt._autoSchedulingPath = {\n\tgetKey: function(rel){\n\t\treturn [rel.lag, rel.link, rel.source, rel.target].join(\"_\");\n\t},\n\tgetVirtualRoot: function(){\n\t\treturn gantt.mixin(\n\t\t\tgantt.getSubtaskDates(),\n\t\t\t{\n\t\t\t\tid: gantt.config.root_id,\n\t\t\t\ttype: gantt.config.types.project,\n\t\t\t\t$source: [],\n\t\t\t\t$target: [],\n\t\t\t\t$virtual: true\n\t\t\t}\n\t\t);\n\t},\n\n\tfilterDuplicates: function(relations){\n\t\tvar keys = {};\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar key = this.getKey(relations[i]);\n\t\t\tif(keys[key]){\n\t\t\t\trelations.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}else{\n\t\t\t\tkeys[key] = true;\n\t\t\t}\n\t\t}\n\t\treturn relations;\n\t},\n\n\tgetLinkedTasks: function(id, includePredecessors){\n\t\tvar startIds = [id];\n\n\t\tvar relations = [];\n\t\tvar visited = {};\n\t\tfor(var i = 0; i < startIds.length; i++){\n\t\t\trelations = relations.concat(this._getLinkedTasks(startIds[i], visited, includePredecessors));\n\t\t}\n\n\t\trelations = this.filterDuplicates(relations);\n\t\treturn relations;\n\t},\n\n\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors){\n\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\n\t\tvar visited = visitedTasks || {};\n\n\t\tvar rootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\n\t\tvar relations = gantt._getSuccessors(rootObj);\n\n\t\tif(includePredecessors){\n\t\t\trelations.push.apply(relations, gantt._getPredecessors(rootObj));\n\t\t}\n\n\t\tvar chainRelations = [];\n\t\tfor(var i=0; i < relations.length; i++){\n\n\t\t\tif(visited[this.getKey(relations[i])])\n\t\t\t\tcontinue;\n\t\t\tvisited[this.getKey(relations[i])] = true;\n\t\t\tchainRelations = chainRelations.concat(this._getLinkedTasks(relations[i].target, visited, true));\n\t\t}\n\n\t\tvar children = gantt.getChildren(rootObj.id);\n\t\tfor(var i=0; i < children.length; i++){\n\t\t\trelations = relations.concat(this._getLinkedTasks(children[i], visited, true));\n\t\t}\n\n\t\tif(chainRelations.length){\n\t\t\trelations = relations.concat(chainRelations);\n\t\t}\n\n\t\treturn relations;\n\t},\n\n\tfindLoops: function(relations){\n\n\t\tvar cycles = [];\n\n\t\thelpers.forEach(relations, function(rel){\n\t\t\tif(rel.target == rel.source)\n\t\t\t\tcycles.push([rel.target, rel.source]);\n\t\t});\n\n\t\tvar graph =  gantt._autoSchedulingGraph;\n\t\tvar vertices = graph.getVertices(relations);\n\n\t\tvar connectedComponents = graph.tarjanStronglyConnectedComponents(vertices, relations);\n\n\t\thelpers.forEach(connectedComponents, function(component){\n\t\t\tif(component.tasks.length > 1){\n\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\n\t\t\t}\n\t\t});\n\n\t\treturn cycles;\n\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\n\t}\n};\n\ngantt._autoSchedulingDateResolver = {\n\tisFirstSmaller: function(small, big, task){\n\t\tif(small.valueOf() < big.valueOf() && gantt._hasDuration(small, big, task))\n\t\t\treturn true;\n\t\treturn false;\n\t},\n\n\tisSmallerOrDefault: function(smallDate, bigDate, task){\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\n\t},\n\n\tresolveRelationDate: function(taskId, relations, getEndDate){\n\t\tvar minStart = null;\n\t\tvar linkId = null;\n\n\t\tvar defaultStart = null;\n\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar relation = relations[i];\n\t\t\ttaskId = relation.target;\n\n\t\t\tdefaultStart = relation.preferredStart;\n\n\t\t\tvar constraintDate = this.getConstraintDate(relation, getEndDate);\n\n\t\t\tif(this.isSmallerOrDefault(defaultStart, constraintDate, gantt.getTask(taskId)) && this.isSmallerOrDefault(minStart, constraintDate, gantt.getTask(taskId))){\n\t\t\t\tminStart = constraintDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\n\t\t}\n\n\t\tif(minStart){\n\t\t\tminStart = gantt.getClosestWorkTime({date:minStart, dir:\"future\", task:gantt.getTask(taskId)});\n\t\t}\n\n\t\treturn {\n\t\t\tlink: linkId,\n\t\t\ttask: taskId,\n\t\t\tstart_date: minStart\n\t\t};\n\t},\n\tgetConstraintDate: function(relation, getEndDate){\n\t\tvar predecessorEnd = getEndDate(relation.source);\n\t\tvar successor = gantt.getTask(relation.target);\n\n\t\tvar successorStart = gantt.getClosestWorkTime({date:predecessorEnd, dir:\"future\", task:successor});\n\n\t\tif(predecessorEnd && relation.lag && relation.lag*1 == relation.lag){\n\t\t\tsuccessorStart = gantt.calculateEndDate({start_date: predecessorEnd, duration: relation.lag*1, task: successor});\n\t\t}\n\n\t\treturn successorStart;\n\t}\n};\n\ngantt._autoSchedulingPlanner = {\n\tgeneratePlan: function(relations){\n\n\t\tvar graph = gantt._autoSchedulingGraph;\n\t\tvar orderedIds = graph.topologicalSort(relations);\n\t\tvar predecessorRelations = {},\n\t\t\tplansHash = {};\n\n\t\thelpers.arrayMap(orderedIds, function(v) {\n\t\t\tvar task = gantt.getTask(v);\n\t\t\tif(task.auto_scheduling === false){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpredecessorRelations[v] = [];\n\t\t\tplansHash[v] = null;\n\t\t});\n\n\t\tfunction getPredecessorEndDate(id){\n\t\t\tvar plan = plansHash[id];\n\t\t\tvar task = gantt.getTask(id);\n\t\t\tvar res;\n\n\t\t\tif(!(plan && (plan.start_date || plan.end_date))){\n\t\t\t\tres = task.end_date;\n\t\t\t}else if(plan.end_date){\n\t\t\t\tres = plan.end_date;\n\t\t\t}else {\n\t\t\t\tres = gantt.calculateEndDate({start_date: plan.start_date, duration: task.duration, task: task});\n\t\t\t}\n\n\t\t\treturn res;\n\t\t}\n\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tif(predecessorRelations[relations[i].target]) {\n\t\t\t\tpredecessorRelations[relations[i].target].push(relations[i]);\n\t\t\t}\n\t\t}\n\n\t\tvar dateResolver = gantt._autoSchedulingDateResolver;\n\n\t\tvar result = [];\n\t\tfor(var i = 0; i < orderedIds.length; i++){\n\t\t\tvar currentId = orderedIds[i];\n\n\t\t\tvar plan = dateResolver.resolveRelationDate(currentId, predecessorRelations[currentId] || [], getPredecessorEndDate);\n\n\n\t\t\tif(plan.start_date && gantt.isLinkExists(plan.link)){\n\t\t\t\tvar link = gantt.getLink(plan.link);\n\t\t\t\tvar task = gantt.getTask(currentId);\n\t\t\t\tvar predecessor = gantt.getTask(link.source);\n\n\t\t\t\tif (task.start_date.valueOf() !== plan.start_date.valueOf() && gantt.callEvent(\"onBeforeTaskAutoSchedule\", [task, plan.start_date, link, predecessor]) === false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplansHash[currentId] = plan;\n\t\t\tif(plan.start_date){\n\t\t\t\tresult.push(plan);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tapplyProjectPlan: function(projectPlan){\n\t\tvar plan, task, link, predecessor;\n\n\t\tvar updateTasks = [];\n\t\tfor(var i = 0; i <  projectPlan.length; i++){\n\t\t\tlink = null;\n\t\t\tpredecessor = null;\n\t\t\tplan = projectPlan[i];\n\n\t\t\tif(!plan.task) continue;\n\n\t\t\ttask = gantt.getTask(plan.task);\n\t\t\tif(plan.link){\n\t\t\t\tlink = gantt.getLink(plan.link);\n\t\t\t\tpredecessor = gantt.getTask(link.source);\n\t\t\t}\n\n\t\t\tvar newDate = null;\n\t\t\tif(plan.start_date && (task.start_date.valueOf() != plan.start_date.valueOf())){\n\t\t\t\tnewDate = plan.start_date;\n\t\t\t}\n\n\t\t\tif(!newDate) continue;\n\t\t\t\n\t\t\ttask.start_date = newDate;\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\n\n\t\t\tupdateTasks.push(task.id);\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [task, newDate, link, predecessor]);\n\n\t\t}\n\t\treturn updateTasks;\n\t}\n};\n\ngantt._autoSchedulingPreferredDates = function(startTask, relations){\n\tfor(var i = 0; i < relations.length; i++){\n\t\tvar rel = relations[i];\n\t\tvar task = gantt.getTask(rel.target);\n\n\t\tif(!gantt.config.auto_scheduling_strict || rel.target == startTask){\n\t\t\trel.preferredStart = new Date(task.start_date);\n\t\t}\n\t}\n};\n\ngantt._autoSchedule = function(id, relations, updateCallback){\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\n\t\treturn;\n\t}\n\tgantt._autoscheduling_in_progress = true;\n\n\tvar path = gantt._autoSchedulingPath;\n\n\tvar updatedTasks = [];\n\n\tvar cycles = path.findLoops(relations);\n\tif(cycles.length){\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\n\t}else{\n\n\t\tvar planner = gantt._autoSchedulingPlanner;\n\t\tgantt._autoSchedulingPreferredDates(id, relations);\n\n\t\tvar plan = planner.generatePlan(relations);\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\n\n\t\tif(updateCallback){\n\t\t\tupdateCallback(updatedTasks);\n\t\t}\n\t}\n\n\tgantt._autoscheduling_in_progress = false;\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\n\n\treturn updatedTasks;\n};\n\ngantt.autoSchedule = function(id, inclusive){\n\n\tif(inclusive === undefined){\n\t\tinclusive = true;\n\t}else{\n\t\tinclusive = !!inclusive;\n\t}\n\tvar relations =  gantt._autoSchedulingPath.getLinkedTasks(id, inclusive);\n\tgantt._autoSchedule(id, relations, gantt._finalizeAutoSchedulingChanges);\n};\n\ngantt._finalizeAutoSchedulingChanges = function(updatedTasks){\n\tfunction resetTime(task){\n\t\tif(batchUpdate)\n\t\t\treturn;\n\n\t\tvar start = task.start_date.valueOf(),\n\t\t\tend = task.end_date.valueOf();\n\n\t\tgantt.resetProjectDates(task);\n\t\tif(task.start_date.valueOf() != start || task.end_date.valueOf() != end){\n\t\t\tbatchUpdate = true;\n\t\t\treturn;\n\t\t}\n\t\tvar children = gantt.getChildren(task.id);\n\t\tfor(var i = 0; !batchUpdate && i < children.length; i++){\n\t\t\tresetTime(gantt.getTask(children[i]));\n\t\t}\n\t}\n\n\tvar batchUpdate = false;\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\n\tif(updatedTasks.length == 1){\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\n\t}else if(updatedTasks.length){\n\t\tbatchUpdate = true;\n\t}\n\n\tfunction payload(){\n\t\tfor(var i = 0; i < updatedTasks.length; i++){\n\t\t\tgantt.updateTask(updatedTasks[i]);\n\t\t}\n\t}\n\tif(batchUpdate){\n\t\tgantt.batchUpdate(payload);\n\t}else{\n\t\tpayload();\n\t}\n\n};\n\ngantt.isCircularLink = function(link){\n\treturn !!gantt._getConnectedGroup(link);\n\n};\n\ngantt._getConnectedGroup = function(link){\n\tvar manager = gantt._autoSchedulingPath;\n\n\tvar allRelations = manager.getLinkedTasks();\n\tif(!gantt.isLinkExists(link.id)){\n\t\tallRelations = allRelations.concat(gantt._formatLink(link));\n\t}\n\n\tvar cycles = manager.findLoops(allRelations);\n\n\tvar found = false;\n\tfor(var i = 0; (i < cycles.length) && !found; i++){\n\t\tvar links = cycles[i].links;\n\t\tfor(var j = 0; j < links.length; j++){\n\t\t\tif(links[j] == link.id){\n\t\t\t\treturn cycles[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\ngantt.findCycles = function(){\n\tvar manager = gantt._autoSchedulingPath;\n\n\tvar allRelations = manager.getLinkedTasks();\n\treturn manager.findLoops(allRelations);\n};\n\ngantt._attachAutoSchedulingHandlers = function(){\n\n\tgantt._autoScheduleAfterLinkChange = function (linkId, link) {\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tgantt.autoSchedule(link.source);\n\t\t}\n\t};\n\n\tgantt.attachEvent(\"onAfterLinkUpdate\", gantt._autoScheduleAfterLinkChange);\n\tgantt.attachEvent(\"onAfterLinkAdd\", gantt._autoScheduleAfterLinkChange);\n\n\tgantt.attachEvent(\"onAfterLinkDelete\", function(id, link){\n\t\tif (this.config.auto_scheduling && !this._autoscheduling_in_progress && this.isTaskExists(link.target)) {\n\t\t\t// after link deleted - auto schedule target for other relations that may be left\n\t\t\tvar target = this.getTask(link.target);\n\t\t\tvar predecessors = this._getPredecessors(target);\n\t\t\tif(predecessors.length){\n\t\t\t\tthis.autoSchedule(predecessors[0].source, false);\n\t\t\t}\n\t\t}\n\t});\n\n\tgantt.attachEvent(\"onParse\", function(){\n\t\tif (gantt.config.auto_scheduling && gantt.config.auto_scheduling_initial) {\n\t\t\tgantt.autoSchedule();\n\t\t}\n\t});\n\n\tgantt._preventCircularLink = function(id, link){\n\t\tif(gantt.isCircularLink(link)){\n\t\t\tgantt.callEvent(\"onCircularLinkError\", [link, gantt._getConnectedGroup(link)]);\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t};\n\n\tgantt._preventDescendantLink = function(id, link){\n\t\tvar source = gantt.getTask(link.source),\n\t\t\ttarget = gantt.getTask(link.target);\n\n\t\tif(!gantt.config.auto_scheduling_descendant_links){\n\t\t\tif((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventCircularLink);\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventDescendantLink);\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventCircularLink);\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventDescendantLink);\n\n\tgantt._datesNotEqual = function(dateA, dateB, taskA, taskB){\n\t\tif(dateA.valueOf() > dateB.valueOf()){\n\t\t\treturn this._hasDuration({start_date: dateB, end_date: dateA, task: taskB});\n\t\t}else{\n\t\t\treturn this._hasDuration({start_date: dateA, end_date: dateB, task: taskA});\n\t\t}\n\t};\n\tgantt._notEqualTaskDates = function(task1, task2){\n\t\tif (this._datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\n\t\t\t((this._datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\n\t\t\t\ttask1.duration != task2.duration) && task1.type != gantt.config.types.milestone)) {\n\t\t\treturn true;\n\t\t}\n\t};\n\n\tvar relations;\n\tvar movedTask;\n\tgantt.attachEvent(\"onBeforeTaskDrag\", function(id, mode, task){\n\t\tif(gantt.config.auto_scheduling_move_projects){\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\t\t\trelations = gantt._autoSchedulingPath.getLinkedTasks(id, true);\n\t\t\tmovedTask = id;\n\t\t}\n\t\treturn true;\n\t});\n\n\tfunction resetToStartLinksLags(taskId, relations){\n\t\tvar skipped = false;\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar originalLink = gantt.getLink(relations[i].id);\n\t\t\tif(originalLink.type == gantt.config.links.start_to_start || originalLink.type == gantt.config.links.start_to_finish){\n\t\t\t\trelations.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t\tskipped = true;\n\t\t\t}\n\t\t}\n\n\t\tif(skipped){\n\t\t\tvar presentLinks = {};\n\t\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\t\tpresentLinks[relations[i].id] = true;\n\t\t\t}\n\n\t\t\tvar updatedLinks = gantt._autoSchedulingPath.getLinkedTasks(taskId, true);\n\t\t\tfor(var i = 0; i < updatedLinks.length; i++){\n\t\t\t\tif(!presentLinks[updatedLinks[i].id]){\n\t\t\t\t\trelations.push(updatedLinks[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgantt._autoScheduleAfterDND = function(taskId, task){\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tvar newTask = this.getTask(taskId);\n\t\t\tif (gantt._notEqualTaskDates(task, newTask)){\n\t\t\t\tif(gantt.config.auto_scheduling_move_projects && movedTask == taskId){\n\n\t\t\t\t\tif(gantt.calculateDuration(task) != gantt.calculateDuration(newTask)){\n\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\n\t\t\t\t\t\t// recalculate these links if task duration has changed\n\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgantt._autoSchedule(taskId, relations, gantt._finalizeAutoSchedulingChanges);\n\t\t\t\t}else{\n\t\t\t\t\tgantt.autoSchedule(newTask.id);\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\t\trelations = null;\n\t\tmovedTask = null;\n\t\treturn true;\n\t};\n\n\tgantt._lightBoxChangesHandler = function (taskId, task) {\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tvar oldTask = this.getTask(taskId);\n\t\t\tif (gantt._notEqualTaskDates(task, oldTask)) {\n\t\t\t\tgantt._autoschedule_lightbox_id = taskId;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\tgantt._lightBoxSaveHandler = function (taskId, task) {\n\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tif (gantt._autoschedule_lightbox_id && gantt._autoschedule_lightbox_id == taskId) {\n\t\t\t\tgantt._autoschedule_lightbox_id = null;\n\t\t\t\tgantt.autoSchedule(task.id);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\n\n\n\tgantt.attachEvent(\"onBeforeTaskChanged\", function(id, mode, task){ return gantt._autoScheduleAfterDND(id, task); });\n\tgantt.attachEvent(\"onLightboxSave\", gantt._lightBoxChangesHandler);\n\tgantt.attachEvent(\"onAfterTaskUpdate\", gantt._lightBoxSaveHandler);\n\n\n};\n\n\ngantt.attachEvent(\"onGanttReady\", function(){\n\tgantt._attachAutoSchedulingHandlers();\n\t// attach handlers only when initialized for the first time\n\tgantt._attachAutoSchedulingHandlers = function(){};\n});\n\n})();\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nvar units = {\n\t\"second\": 1,\n\t\"minute\": 60,\n\t\"hour\": 60 * 60,\n\t\"day\": 60 * 60 * 24,\n\t\"week\": 60 * 60 * 24 * 7,\n\t\"month\": 60 * 60 * 24 * 30,\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\n\t\"year\": 60 * 60 * 24 * 365\n};\nfunction getSecondsInUnit(unit){\n\treturn units[unit] || units.hour;\n}\n\nfunction forEach(arr, callback){\n\tvar workArray = arr.slice();\n\tfor(var i = 0; i < workArray.length; i++){\n\t\tcallback(workArray[i], i);\n\t}\n}\n\nfunction arrayMap(arr, callback){\n\tvar workArray = arr.slice();\n\tvar resArray = [];\n\n\tfor(var i = 0; i < workArray.length; i++){\n\t\tresArray.push(callback(workArray[i], i));\n\t}\n\n\treturn resArray;\n}\n\nmodule.exports = {\n\tgetSecondsInUnit: getSecondsInUnit,\n\tforEach: forEach,\n\tarrayMap: arrayMap\n};\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// dhtmlxgantt_auto_scheduling.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c4a39cba6e1e70e8474e","module.exports = function(gantt) {\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\t\tvar role = getTarget ? \"target\" : \"source\";\n\t\tgantt.assert(task, \"Link \" + role + \" not found. Task id=\" + taskId + \", link id=\" + link.id);\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\n\tgantt._formatLink = function (link) {\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))) {\n\t\t\treturn relations;\n\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t});\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0; i < from.length; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0; j < to.length; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target));\n\t\t\t}\n\t\t}\n\n\t\treturn relations;\n\t};\n\ngantt._isAutoSchedulable = function(task){\n\treturn task.auto_scheduling !== false;\n};\n\ngantt._getImplicitLinks = function(link, parent, selectOffset){\n\tvar relations = [];\n\tif(this.isSummaryTask(parent)){\n\t\tthis.eachTask(function(c){\n\t\t\tif(!this.isSummaryTask(c))\n\t\t\t\trelations.push({task: c.id, lag: selectOffset(c)});\n\t\t}, parent.id);\n\t}else{\n\t\trelations.push({task:parent.id, lag: 0});\n\t}\n\n\t\treturn relations;\n\t};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\tfor(var i = 0; i < linksIds.length; i++){\n\t\tvar link = this.getLink(linksIds[i]);\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\tvar target = this.getTask(link.target);\n\t\t\tif(this._isAutoSchedulable(target)){\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t}\n\t\t}\n\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\t\tvar successors = [];\n\tvar stop = false;\n\tvar inheritedRelations = [];\n\tif(this.isTaskExists(task.id)){\n\t\tthis.eachParent(function(parent){\n\t\t\tif(stop)\n\t\t\t\treturn;\n\n\t\t\tif(this.isSummaryTask(parent)){\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\n\t\t\t\t\tstop = true;\n\t\t\t\t}else{\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, this._getDirectDependencies(parent, selectSuccessors));\n\t\t\t\t}\n\t\t\t}\n\t\t}, task.id, this);\n\n\t\t\tfor (var i = 0; i < inheritedRelations.length; i++) {\n\n\t\t\t\tvar relProperty = selectSuccessors ? inheritedRelations[i].source : inheritedRelations[i].target;\n\n\t\t\t\tif (relProperty == task.id) {\n\t\t\t\t\tsuccessors.push(inheritedRelations[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\n\tgantt._getSuccessors = function (task) {\n\t\treturn this._getDirectSuccessors(task).concat(this._getInheritedSuccessors(task));\n\t};\n\n\tgantt._getPredecessors = function (task) {\n\t\treturn this._getDirectPredecessors(task).concat(this._getInheritedPredecessors(task));\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\treturn res;\n\t};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/core/links_common.js\n// module id = 1\n// module chunks = 1 3","require(\"../core/links_common\")(gantt);\n\ngantt.config.auto_scheduling = false;\ngantt.config.auto_scheduling_descendant_links = false;\ngantt.config.auto_scheduling_initial = true;\ngantt.config.auto_scheduling_strict = false;\ngantt.config.auto_scheduling_move_projects = true;\n\n(function(){\n\nvar helpers = require(\"../utils/helpers\");\n\n\ngantt._autoSchedulingGraph = {\n\tgetVertices: function(relations){\n\t\tvar ids = {};\n\n\t\thelpers.forEach(relations, function(rel){\n\t\t\tids[rel.target] = rel.target;\n\t\t\tids[rel.source] = rel.source;\n\t\t});\n\n\t\tvar vertices = [];\n\t\tfor(var i in ids){\n\t\t\tvertices.push(ids[i]);\n\t\t}\n\n\t\treturn vertices.sort(function(a, b){ return gantt.getGlobalTaskIndex(a) - gantt.getGlobalTaskIndex(b);});\n\t},\n\ttopologicalSort: function(edges){\n\t\tvar vertices = this.getVertices(edges);\n\t\tvar hash = {};\n\n\t\tfor(var i = 0; i < vertices.length; i ++){\n\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\n\t\t}\n\n\t\tfor(var i = 0; i < edges.length; i++){\n\t\t\tvar successor = hash[edges[i].target];\n\t\t\tsuccessor.$target.push(i);\n\t\t\tsuccessor.$incoming = successor.$target.length;\n\t\t\thash[edges[i].source].$source.push(i);\n\n\t\t}\n\n\t\t// topological sort, Kahn's algorithm\n\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\n\n\t\tvar L = [];\n\n\t\twhile(S.length){\n\t\t\tvar n = S.pop();\n\n\t\t\tL.push(n);\n\n\t\t\tvar node = hash[n];\n\n\t\t\tfor(var i = 0; i < node.$source.length; i++){\n\t\t\t\tvar m = hash[edges[node.$source[i]].target];\n\t\t\t\tm.$incoming--;\n\t\t\t\tif(!m.$incoming){\n\t\t\t\t\tS.push(m.id);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn L;\n\n\t},\n\ttarjanStronglyConnectedComponents: function(vertices, edges){\n\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\t\tvar verticesHash = {};\n\n\t\tvar index = 0;\n\t\tvar S = [];\n\t\tvar connectedEdges = [];\n\t\tvar connectedComponents = [];\n\n\t\thelpers.forEach(vertices, function(vertexId){\n\t\t\tvar vertex = getVertex(vertexId);\n\t\t\tif(vertex.index === undefined){\n\t\t\t\tstrongConnect(vertexId);\n\t\t\t}\n\t\t});\n\n\t\tfunction strongConnect(vertexId, previousLink){\n\t\t\tvar v = getVertex(vertexId);\n\t\t\tv.index = index;\n\t\t\tv.lowLink = index;\n\t\t\tindex++;\n\n\t\t\tif(previousLink){\n\t\t\t\tconnectedEdges.push(previousLink);\n\t\t\t}\n\n\t\t\tS.push(v);\n\t\t\tv.onStack = true;\n\n\t\t\t// Consider successors of v\n\t\t\thelpers.forEach(edges, function(edge){\n\t\t\t\tif(edge.source != vertexId) return;\n\n\t\t\t\tvar v = getVertex(edge.source);\n\t\t\t\tvar w = getVertex(edge.target);\n\t\t\t\tif(w.index === undefined){\n\t\t\t\t\t// Successor w has not yet been visited; recurse on it\n\t\t\t\t\tstrongConnect(edge.target, edge);\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\n\t\t\t\t}else if(w.onStack){\n\t\t\t\t\t// Successor w is in stack S and hence in the current SCC\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\n\t\t\t\t\tconnectedEdges.push(edge);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t// If v is a root node, pop the stack and generate an SCC\n\t\t\tif(v.lowLink == v.index){\n\t\t\t\tvar connectedComponent = {tasks: [], links:[]};\n\t\t\t\tvar w;\n\t\t\t\tdo{\n\t\t\t\t\tvar rel = connectedEdges.pop();\n\t\t\t\t\tw = S.pop();\n\t\t\t\t\tw.onStack = false;\n\t\t\t\t\tconnectedComponent.tasks.push(w.id);\n\t\t\t\t\tif(rel){\n\t\t\t\t\t\tconnectedComponent.links.push(rel.id);\n\t\t\t\t\t}\n\t\t\t\t}while(w.id != v.id);\n\t\t\t\tconnectedComponents.push(connectedComponent);\n\t\t\t}\n\n\t\t}\n\n\t\treturn connectedComponents;\n\n\t\tfunction getVertex(id){\n\t\t\tif(!verticesHash[id]){\n\t\t\t\tverticesHash[id] = {id: id};\n\t\t\t}\n\n\t\t\treturn verticesHash[id];\n\t\t}\n\n\t}\n\n};\n\ngantt._autoSchedulingPath = {\n\tgetKey: function(rel){\n\t\treturn [rel.lag, rel.link, rel.source, rel.target].join(\"_\");\n\t},\n\tgetVirtualRoot: function(){\n\t\treturn gantt.mixin(\n\t\t\tgantt.getSubtaskDates(),\n\t\t\t{\n\t\t\t\tid: gantt.config.root_id,\n\t\t\t\ttype: gantt.config.types.project,\n\t\t\t\t$source: [],\n\t\t\t\t$target: [],\n\t\t\t\t$virtual: true\n\t\t\t}\n\t\t);\n\t},\n\n\tfilterDuplicates: function(relations){\n\t\tvar keys = {};\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar key = this.getKey(relations[i]);\n\t\t\tif(keys[key]){\n\t\t\t\trelations.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}else{\n\t\t\t\tkeys[key] = true;\n\t\t\t}\n\t\t}\n\t\treturn relations;\n\t},\n\n\tgetLinkedTasks: function(id, includePredecessors){\n\t\tvar startIds = [id];\n\n\t\tvar relations = [];\n\t\tvar visited = {};\n\t\tfor(var i = 0; i < startIds.length; i++){\n\t\t\trelations = relations.concat(this._getLinkedTasks(startIds[i], visited, includePredecessors));\n\t\t}\n\n\t\trelations = this.filterDuplicates(relations);\n\t\treturn relations;\n\t},\n\n\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors){\n\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\n\t\tvar visited = visitedTasks || {};\n\n\t\tvar rootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\n\t\tvar relations = gantt._getSuccessors(rootObj);\n\n\t\tif(includePredecessors){\n\t\t\trelations.push.apply(relations, gantt._getPredecessors(rootObj));\n\t\t}\n\n\t\tvar chainRelations = [];\n\t\tfor(var i=0; i < relations.length; i++){\n\n\t\t\tif(visited[this.getKey(relations[i])])\n\t\t\t\tcontinue;\n\t\t\tvisited[this.getKey(relations[i])] = true;\n\t\t\tchainRelations = chainRelations.concat(this._getLinkedTasks(relations[i].target, visited, true));\n\t\t}\n\n\t\tvar children = gantt.getChildren(rootObj.id);\n\t\tfor(var i=0; i < children.length; i++){\n\t\t\trelations = relations.concat(this._getLinkedTasks(children[i], visited, true));\n\t\t}\n\n\t\tif(chainRelations.length){\n\t\t\trelations = relations.concat(chainRelations);\n\t\t}\n\n\t\treturn relations;\n\t},\n\n\tfindLoops: function(relations){\n\n\t\tvar cycles = [];\n\n\t\thelpers.forEach(relations, function(rel){\n\t\t\tif(rel.target == rel.source)\n\t\t\t\tcycles.push([rel.target, rel.source]);\n\t\t});\n\n\t\tvar graph =  gantt._autoSchedulingGraph;\n\t\tvar vertices = graph.getVertices(relations);\n\n\t\tvar connectedComponents = graph.tarjanStronglyConnectedComponents(vertices, relations);\n\n\t\thelpers.forEach(connectedComponents, function(component){\n\t\t\tif(component.tasks.length > 1){\n\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\n\t\t\t}\n\t\t});\n\n\t\treturn cycles;\n\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\n\t}\n};\n\ngantt._autoSchedulingDateResolver = {\n\tisFirstSmaller: function(small, big, task){\n\t\tif(small.valueOf() < big.valueOf() && gantt._hasDuration(small, big, task))\n\t\t\treturn true;\n\t\treturn false;\n\t},\n\n\tisSmallerOrDefault: function(smallDate, bigDate, task){\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\n\t},\n\n\tresolveRelationDate: function(taskId, relations, getEndDate){\n\t\tvar minStart = null;\n\t\tvar linkId = null;\n\n\t\tvar defaultStart = null;\n\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar relation = relations[i];\n\t\t\ttaskId = relation.target;\n\n\t\t\tdefaultStart = relation.preferredStart;\n\n\t\t\tvar constraintDate = this.getConstraintDate(relation, getEndDate);\n\n\t\t\tif(this.isSmallerOrDefault(defaultStart, constraintDate, gantt.getTask(taskId)) && this.isSmallerOrDefault(minStart, constraintDate, gantt.getTask(taskId))){\n\t\t\t\tminStart = constraintDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\n\t\t}\n\n\t\tif(minStart){\n\t\t\tminStart = gantt.getClosestWorkTime({date:minStart, dir:\"future\", task:gantt.getTask(taskId)});\n\t\t}\n\n\t\treturn {\n\t\t\tlink: linkId,\n\t\t\ttask: taskId,\n\t\t\tstart_date: minStart\n\t\t};\n\t},\n\tgetConstraintDate: function(relation, getEndDate){\n\t\tvar predecessorEnd = getEndDate(relation.source);\n\t\tvar successor = gantt.getTask(relation.target);\n\n\t\tvar successorStart = gantt.getClosestWorkTime({date:predecessorEnd, dir:\"future\", task:successor});\n\n\t\tif(predecessorEnd && relation.lag && relation.lag*1 == relation.lag){\n\t\t\tsuccessorStart = gantt.calculateEndDate({start_date: predecessorEnd, duration: relation.lag*1, task: successor});\n\t\t}\n\n\t\treturn successorStart;\n\t}\n};\n\ngantt._autoSchedulingPlanner = {\n\tgeneratePlan: function(relations){\n\n\t\tvar graph = gantt._autoSchedulingGraph;\n\t\tvar orderedIds = graph.topologicalSort(relations);\n\t\tvar predecessorRelations = {},\n\t\t\tplansHash = {};\n\n\t\thelpers.arrayMap(orderedIds, function(v) {\n\t\t\tvar task = gantt.getTask(v);\n\t\t\tif(task.auto_scheduling === false){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpredecessorRelations[v] = [];\n\t\t\tplansHash[v] = null;\n\t\t});\n\n\t\tfunction getPredecessorEndDate(id){\n\t\t\tvar plan = plansHash[id];\n\t\t\tvar task = gantt.getTask(id);\n\t\t\tvar res;\n\n\t\t\tif(!(plan && (plan.start_date || plan.end_date))){\n\t\t\t\tres = task.end_date;\n\t\t\t}else if(plan.end_date){\n\t\t\t\tres = plan.end_date;\n\t\t\t}else {\n\t\t\t\tres = gantt.calculateEndDate({start_date: plan.start_date, duration: task.duration, task: task});\n\t\t\t}\n\n\t\t\treturn res;\n\t\t}\n\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tif(predecessorRelations[relations[i].target]) {\n\t\t\t\tpredecessorRelations[relations[i].target].push(relations[i]);\n\t\t\t}\n\t\t}\n\n\t\tvar dateResolver = gantt._autoSchedulingDateResolver;\n\n\t\tvar result = [];\n\t\tfor(var i = 0; i < orderedIds.length; i++){\n\t\t\tvar currentId = orderedIds[i];\n\n\t\t\tvar plan = dateResolver.resolveRelationDate(currentId, predecessorRelations[currentId] || [], getPredecessorEndDate);\n\n\n\t\t\tif(plan.start_date && gantt.isLinkExists(plan.link)){\n\t\t\t\tvar link = gantt.getLink(plan.link);\n\t\t\t\tvar task = gantt.getTask(currentId);\n\t\t\t\tvar predecessor = gantt.getTask(link.source);\n\n\t\t\t\tif (task.start_date.valueOf() !== plan.start_date.valueOf() && gantt.callEvent(\"onBeforeTaskAutoSchedule\", [task, plan.start_date, link, predecessor]) === false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplansHash[currentId] = plan;\n\t\t\tif(plan.start_date){\n\t\t\t\tresult.push(plan);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tapplyProjectPlan: function(projectPlan){\n\t\tvar plan, task, link, predecessor;\n\n\t\tvar updateTasks = [];\n\t\tfor(var i = 0; i <  projectPlan.length; i++){\n\t\t\tlink = null;\n\t\t\tpredecessor = null;\n\t\t\tplan = projectPlan[i];\n\n\t\t\tif(!plan.task) continue;\n\n\t\t\ttask = gantt.getTask(plan.task);\n\t\t\tif(plan.link){\n\t\t\t\tlink = gantt.getLink(plan.link);\n\t\t\t\tpredecessor = gantt.getTask(link.source);\n\t\t\t}\n\n\t\t\tvar newDate = null;\n\t\t\tif(plan.start_date && (task.start_date.valueOf() != plan.start_date.valueOf())){\n\t\t\t\tnewDate = plan.start_date;\n\t\t\t}\n\n\t\t\tif(!newDate) continue;\n\t\t\t\n\t\t\ttask.start_date = newDate;\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\n\n\t\t\tupdateTasks.push(task.id);\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [task, newDate, link, predecessor]);\n\n\t\t}\n\t\treturn updateTasks;\n\t}\n};\n\ngantt._autoSchedulingPreferredDates = function(startTask, relations){\n\tfor(var i = 0; i < relations.length; i++){\n\t\tvar rel = relations[i];\n\t\tvar task = gantt.getTask(rel.target);\n\n\t\tif(!gantt.config.auto_scheduling_strict || rel.target == startTask){\n\t\t\trel.preferredStart = new Date(task.start_date);\n\t\t}\n\t}\n};\n\ngantt._autoSchedule = function(id, relations, updateCallback){\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\n\t\treturn;\n\t}\n\tgantt._autoscheduling_in_progress = true;\n\n\tvar path = gantt._autoSchedulingPath;\n\n\tvar updatedTasks = [];\n\n\tvar cycles = path.findLoops(relations);\n\tif(cycles.length){\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\n\t}else{\n\n\t\tvar planner = gantt._autoSchedulingPlanner;\n\t\tgantt._autoSchedulingPreferredDates(id, relations);\n\n\t\tvar plan = planner.generatePlan(relations);\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\n\n\t\tif(updateCallback){\n\t\t\tupdateCallback(updatedTasks);\n\t\t}\n\t}\n\n\tgantt._autoscheduling_in_progress = false;\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\n\n\treturn updatedTasks;\n};\n\ngantt.autoSchedule = function(id, inclusive){\n\n\tif(inclusive === undefined){\n\t\tinclusive = true;\n\t}else{\n\t\tinclusive = !!inclusive;\n\t}\n\tvar relations =  gantt._autoSchedulingPath.getLinkedTasks(id, inclusive);\n\tgantt._autoSchedule(id, relations, gantt._finalizeAutoSchedulingChanges);\n};\n\ngantt._finalizeAutoSchedulingChanges = function(updatedTasks){\n\tfunction resetTime(task){\n\t\tif(batchUpdate)\n\t\t\treturn;\n\n\t\tvar start = task.start_date.valueOf(),\n\t\t\tend = task.end_date.valueOf();\n\n\t\tgantt.resetProjectDates(task);\n\t\tif(task.start_date.valueOf() != start || task.end_date.valueOf() != end){\n\t\t\tbatchUpdate = true;\n\t\t\treturn;\n\t\t}\n\t\tvar children = gantt.getChildren(task.id);\n\t\tfor(var i = 0; !batchUpdate && i < children.length; i++){\n\t\t\tresetTime(gantt.getTask(children[i]));\n\t\t}\n\t}\n\n\tvar batchUpdate = false;\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\n\tif(updatedTasks.length == 1){\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\n\t}else if(updatedTasks.length){\n\t\tbatchUpdate = true;\n\t}\n\n\tfunction payload(){\n\t\tfor(var i = 0; i < updatedTasks.length; i++){\n\t\t\tgantt.updateTask(updatedTasks[i]);\n\t\t}\n\t}\n\tif(batchUpdate){\n\t\tgantt.batchUpdate(payload);\n\t}else{\n\t\tpayload();\n\t}\n\n};\n\ngantt.isCircularLink = function(link){\n\treturn !!gantt._getConnectedGroup(link);\n\n};\n\ngantt._getConnectedGroup = function(link){\n\tvar manager = gantt._autoSchedulingPath;\n\n\tvar allRelations = manager.getLinkedTasks();\n\tif(!gantt.isLinkExists(link.id)){\n\t\tallRelations = allRelations.concat(gantt._formatLink(link));\n\t}\n\n\tvar cycles = manager.findLoops(allRelations);\n\n\tvar found = false;\n\tfor(var i = 0; (i < cycles.length) && !found; i++){\n\t\tvar links = cycles[i].links;\n\t\tfor(var j = 0; j < links.length; j++){\n\t\t\tif(links[j] == link.id){\n\t\t\t\treturn cycles[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\ngantt.findCycles = function(){\n\tvar manager = gantt._autoSchedulingPath;\n\n\tvar allRelations = manager.getLinkedTasks();\n\treturn manager.findLoops(allRelations);\n};\n\ngantt._attachAutoSchedulingHandlers = function(){\n\n\tgantt._autoScheduleAfterLinkChange = function (linkId, link) {\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tgantt.autoSchedule(link.source);\n\t\t}\n\t};\n\n\tgantt.attachEvent(\"onAfterLinkUpdate\", gantt._autoScheduleAfterLinkChange);\n\tgantt.attachEvent(\"onAfterLinkAdd\", gantt._autoScheduleAfterLinkChange);\n\n\tgantt.attachEvent(\"onAfterLinkDelete\", function(id, link){\n\t\tif (this.config.auto_scheduling && !this._autoscheduling_in_progress && this.isTaskExists(link.target)) {\n\t\t\t// after link deleted - auto schedule target for other relations that may be left\n\t\t\tvar target = this.getTask(link.target);\n\t\t\tvar predecessors = this._getPredecessors(target);\n\t\t\tif(predecessors.length){\n\t\t\t\tthis.autoSchedule(predecessors[0].source, false);\n\t\t\t}\n\t\t}\n\t});\n\n\tgantt.attachEvent(\"onParse\", function(){\n\t\tif (gantt.config.auto_scheduling && gantt.config.auto_scheduling_initial) {\n\t\t\tgantt.autoSchedule();\n\t\t}\n\t});\n\n\tgantt._preventCircularLink = function(id, link){\n\t\tif(gantt.isCircularLink(link)){\n\t\t\tgantt.callEvent(\"onCircularLinkError\", [link, gantt._getConnectedGroup(link)]);\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t};\n\n\tgantt._preventDescendantLink = function(id, link){\n\t\tvar source = gantt.getTask(link.source),\n\t\t\ttarget = gantt.getTask(link.target);\n\n\t\tif(!gantt.config.auto_scheduling_descendant_links){\n\t\t\tif((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventCircularLink);\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventDescendantLink);\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventCircularLink);\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventDescendantLink);\n\n\tgantt._datesNotEqual = function(dateA, dateB, taskA, taskB){\n\t\tif(dateA.valueOf() > dateB.valueOf()){\n\t\t\treturn this._hasDuration({start_date: dateB, end_date: dateA, task: taskB});\n\t\t}else{\n\t\t\treturn this._hasDuration({start_date: dateA, end_date: dateB, task: taskA});\n\t\t}\n\t};\n\tgantt._notEqualTaskDates = function(task1, task2){\n\t\tif (this._datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\n\t\t\t((this._datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\n\t\t\t\ttask1.duration != task2.duration) && task1.type != gantt.config.types.milestone)) {\n\t\t\treturn true;\n\t\t}\n\t};\n\n\tvar relations;\n\tvar movedTask;\n\tgantt.attachEvent(\"onBeforeTaskDrag\", function(id, mode, task){\n\t\tif(gantt.config.auto_scheduling_move_projects){\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\t\t\trelations = gantt._autoSchedulingPath.getLinkedTasks(id, true);\n\t\t\tmovedTask = id;\n\t\t}\n\t\treturn true;\n\t});\n\n\tfunction resetToStartLinksLags(taskId, relations){\n\t\tvar skipped = false;\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar originalLink = gantt.getLink(relations[i].id);\n\t\t\tif(originalLink.type == gantt.config.links.start_to_start || originalLink.type == gantt.config.links.start_to_finish){\n\t\t\t\trelations.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t\tskipped = true;\n\t\t\t}\n\t\t}\n\n\t\tif(skipped){\n\t\t\tvar presentLinks = {};\n\t\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\t\tpresentLinks[relations[i].id] = true;\n\t\t\t}\n\n\t\t\tvar updatedLinks = gantt._autoSchedulingPath.getLinkedTasks(taskId, true);\n\t\t\tfor(var i = 0; i < updatedLinks.length; i++){\n\t\t\t\tif(!presentLinks[updatedLinks[i].id]){\n\t\t\t\t\trelations.push(updatedLinks[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgantt._autoScheduleAfterDND = function(taskId, task){\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tvar newTask = this.getTask(taskId);\n\t\t\tif (gantt._notEqualTaskDates(task, newTask)){\n\t\t\t\tif(gantt.config.auto_scheduling_move_projects && movedTask == taskId){\n\n\t\t\t\t\tif(gantt.calculateDuration(task) != gantt.calculateDuration(newTask)){\n\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\n\t\t\t\t\t\t// recalculate these links if task duration has changed\n\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgantt._autoSchedule(taskId, relations, gantt._finalizeAutoSchedulingChanges);\n\t\t\t\t}else{\n\t\t\t\t\tgantt.autoSchedule(newTask.id);\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\t\trelations = null;\n\t\tmovedTask = null;\n\t\treturn true;\n\t};\n\n\tgantt._lightBoxChangesHandler = function (taskId, task) {\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tvar oldTask = this.getTask(taskId);\n\t\t\tif (gantt._notEqualTaskDates(task, oldTask)) {\n\t\t\t\tgantt._autoschedule_lightbox_id = taskId;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\tgantt._lightBoxSaveHandler = function (taskId, task) {\n\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tif (gantt._autoschedule_lightbox_id && gantt._autoschedule_lightbox_id == taskId) {\n\t\t\t\tgantt._autoschedule_lightbox_id = null;\n\t\t\t\tgantt.autoSchedule(task.id);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\n\n\n\tgantt.attachEvent(\"onBeforeTaskChanged\", function(id, mode, task){ return gantt._autoScheduleAfterDND(id, task); });\n\tgantt.attachEvent(\"onLightboxSave\", gantt._lightBoxChangesHandler);\n\tgantt.attachEvent(\"onAfterTaskUpdate\", gantt._lightBoxSaveHandler);\n\n\n};\n\n\ngantt.attachEvent(\"onGanttReady\", function(){\n\tgantt._attachAutoSchedulingHandlers();\n\t// attach handlers only when initialized for the first time\n\tgantt._attachAutoSchedulingHandlers = function(){};\n});\n\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/ext/auto_scheduling.js\n// module id = 3\n// module chunks = 1","var units = {\n\t\"second\": 1,\n\t\"minute\": 60,\n\t\"hour\": 60 * 60,\n\t\"day\": 60 * 60 * 24,\n\t\"week\": 60 * 60 * 24 * 7,\n\t\"month\": 60 * 60 * 24 * 30,\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\n\t\"year\": 60 * 60 * 24 * 365\n};\nfunction getSecondsInUnit(unit){\n\treturn units[unit] || units.hour;\n}\n\nfunction forEach(arr, callback){\n\tvar workArray = arr.slice();\n\tfor(var i = 0; i < workArray.length; i++){\n\t\tcallback(workArray[i], i);\n\t}\n}\n\nfunction arrayMap(arr, callback){\n\tvar workArray = arr.slice();\n\tvar resArray = [];\n\n\tfor(var i = 0; i < workArray.length; i++){\n\t\tresArray.push(callback(workArray[i], i));\n\t}\n\n\treturn resArray;\n}\n\nmodule.exports = {\n\tgetSecondsInUnit: getSecondsInUnit,\n\tforEach: forEach,\n\tarrayMap: arrayMap\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/utils/helpers.js\n// module id = 4\n// module chunks = 1"],"sourceRoot":""}