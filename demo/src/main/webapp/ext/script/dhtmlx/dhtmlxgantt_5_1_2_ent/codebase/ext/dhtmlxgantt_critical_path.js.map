{"version":3,"sources":["webpack:///dhtmlxgantt_critical_path.js","webpack:///webpack/bootstrap c4a39cba6e1e70e8474e","webpack:///./sources/core/links_common.js","webpack:///./sources/ext/critical_path.js"],"names":["Gantt","plugin","gantt","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_get_linked_task","link","getTarget","task","taskId","target","source","isTaskExists","getTask","role","assert","id","_get_link_target","_get_link_source","_formatLink","relations","this","isChildOf","isSummaryTask","from","_getImplicitLinks","respectTargetOffset","config","auto_scheduling_move_projects","targetDates","getSubtaskDates","start_date","end_date","to","$target","length","getState","drag_id","calculateDuration","fromTask","j","toTask","lag","subtaskLink","type","push","_convertToFinishToStartLink","_isAutoSchedulable","auto_scheduling","parent","selectOffset","eachTask","_getDirectDependencies","selectSuccessors","links","successors","linksIds","$source","getLink","concat","_getInheritedDependencies","stop","inheritedRelations","eachParent","apply","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","_getSuccessors","_getPredecessors","sourceTask","targetTask","res","finish_to_start","preferredStart","additionalLag","start_to_start","duration","finish_to_finish","start_to_finish","highlight_critical_path","_criticalPathHandler","render","attachEvent","_isCriticalTask","chain","path","_isProjectEnd","_getDependencies","next","_getSlack","isCriticalTask","undefined","isCriticalLink","getSlack","task1","task2","common","slacks","Math","min","next_task","relation","types","getTaskType","milestone","_getProjectEnd","tasks","getTaskByTime","sort","a","b","_hasDuration","_getSummaryPredecessors","predecessors"],"mappings":"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","file":"dhtmlxgantt_critical_path.js","sourcesContent":["/*!\n * @license\n * \n * dhtmlxGantt v.5.1.2 Professional\n * This software is covered by DHTMLX Enterprise License. Usage without proper license is prohibited.\n * \n * (c) Dinamenta, UAB.\n * \n */\nGantt.plugin(function(gantt){\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(gantt) {\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\t\tvar role = getTarget ? \"target\" : \"source\";\n\t\tgantt.assert(task, \"Link \" + role + \" not found. Task id=\" + taskId + \", link id=\" + link.id);\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\n\tgantt._formatLink = function (link) {\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))) {\n\t\t\treturn relations;\n\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t});\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0; i < from.length; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0; j < to.length; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target));\n\t\t\t}\n\t\t}\n\n\t\treturn relations;\n\t};\n\ngantt._isAutoSchedulable = function(task){\n\treturn task.auto_scheduling !== false;\n};\n\ngantt._getImplicitLinks = function(link, parent, selectOffset){\n\tvar relations = [];\n\tif(this.isSummaryTask(parent)){\n\t\tthis.eachTask(function(c){\n\t\t\tif(!this.isSummaryTask(c))\n\t\t\t\trelations.push({task: c.id, lag: selectOffset(c)});\n\t\t}, parent.id);\n\t}else{\n\t\trelations.push({task:parent.id, lag: 0});\n\t}\n\n\t\treturn relations;\n\t};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\tfor(var i = 0; i < linksIds.length; i++){\n\t\tvar link = this.getLink(linksIds[i]);\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\tvar target = this.getTask(link.target);\n\t\t\tif(this._isAutoSchedulable(target)){\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t}\n\t\t}\n\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\t\tvar successors = [];\n\tvar stop = false;\n\tvar inheritedRelations = [];\n\tif(this.isTaskExists(task.id)){\n\t\tthis.eachParent(function(parent){\n\t\t\tif(stop)\n\t\t\t\treturn;\n\n\t\t\tif(this.isSummaryTask(parent)){\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\n\t\t\t\t\tstop = true;\n\t\t\t\t}else{\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, this._getDirectDependencies(parent, selectSuccessors));\n\t\t\t\t}\n\t\t\t}\n\t\t}, task.id, this);\n\n\t\t\tfor (var i = 0; i < inheritedRelations.length; i++) {\n\n\t\t\t\tvar relProperty = selectSuccessors ? inheritedRelations[i].source : inheritedRelations[i].target;\n\n\t\t\t\tif (relProperty == task.id) {\n\t\t\t\t\tsuccessors.push(inheritedRelations[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\n\tgantt._getSuccessors = function (task) {\n\t\treturn this._getDirectSuccessors(task).concat(this._getInheritedSuccessors(task));\n\t};\n\n\tgantt._getPredecessors = function (task) {\n\t\treturn this._getDirectPredecessors(task).concat(this._getInheritedPredecessors(task));\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\treturn res;\n\t};\n};\n\n/***/ }),\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(6);\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(1)(gantt);\n\ngantt.config.highlight_critical_path = false;\ngantt._criticalPathHandler = function(){\n\tif(gantt.config.highlight_critical_path)\n\t\tgantt.render();\n};\ngantt.attachEvent(\"onAfterLinkAdd\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterLinkUpdate\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterLinkDelete\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterTaskAdd\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterTaskUpdate\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterTaskDelete\", gantt._criticalPathHandler);\n\n\ngantt._isCriticalTask = function(task, chain){\n\tif(!task || !task.id) return;\n\tvar path = chain || {};\n\n\tif(this._isProjectEnd(task)){\n\t\treturn true;\n\t}else{\n\t\tpath[task.id] = true;\n\t\tvar successors = this._getDependencies(task);\n\t\tfor(var i=0; i < successors.length; i++){\n\t\t\tvar next = this.getTask(successors[i].target);\n\t\t\tif(this._getSlack(task, next, successors[i]) <= 0 && (!path[next.id] && this._isCriticalTask(next, path)))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\ngantt.isCriticalTask = function (task) {\n\tgantt.assert(!!(task && task.id !== undefined), \"Invalid argument for gantt.isCriticalTask\");\n\treturn this._isCriticalTask(task, {});\n};\n\ngantt.isCriticalLink = function (link) {\n\treturn this.isCriticalTask(gantt.getTask(link.source));\n};\n\ngantt.getSlack = function(task1, task2){\n\tvar relations = [];\n\tvar common = {};\n\tfor(var i=0; i < task1.$source.length; i++){\n\t\tcommon[task1.$source[i]] = true;\n\t}\n\tfor(var i=0; i < task2.$target.length; i++){\n\t\tif(common[task2.$target[i]])\n\t\t\trelations.push(task2.$target[i]);\n\t}\n\n\tvar slacks = [];\n\tfor(var i=0; i < relations.length; i++){\n\t\tvar link = this.getLink(relations[i]);\n\t\tslacks.push(this._getSlack(task1, task2, this._convertToFinishToStartLink(link.id, link, task1, task2)));\n\t}\n\n\treturn Math.min.apply(Math, slacks);\n};\n\ngantt._getSlack = function (task, next_task, relation) {\n\t// relation - link expressed as finish-to-start (gantt._convertToFinishToStartLink)\n\tvar types = this.config.types;\n\n\tvar from = null;\n\tif(this.getTaskType(task.type) == types.milestone){\n\t\tfrom = task.start_date;\n\t}else{\n\t\tfrom = task.end_date;\n\t}\n\n\tvar to = next_task.start_date;\n\n\tvar duration = 0;\n\tif(+from > +to){\n\t\tduration = -this.calculateDuration({start_date: to, end_date: from, task: task});\n\t}else{\n\t\tduration = this.calculateDuration({start_date: from, end_date: to, task: task});\n\t}\n\n\tvar lag = relation.lag;\n\tif(lag && lag*1 == lag){\n\t\tduration -= lag;\n\t}\n\n\treturn duration;\n};\n\ngantt._getProjectEnd = function () {\n\tvar tasks = gantt.getTaskByTime();\n\ttasks = tasks.sort(function (a, b) { return +a.end_date > +b.end_date ? 1 : -1; });\n\treturn tasks.length ? tasks[tasks.length - 1].end_date : null;\n};\n\ngantt._isProjectEnd = function (task) {\n\treturn !(this._hasDuration({start_date:task.end_date, end_date: this._getProjectEnd(), task:task}));\n};\n\ngantt._getSummaryPredecessors = function(task){\n\tvar predecessors = [];\n\n\t// all constraints that are applied to summary parents must be applied to the task\n\tthis.eachParent(function(parent){\n\t\tif(this.isSummaryTask(parent))\n\t\t\tpredecessors = predecessors.concat(gantt._getDependencies(parent));\n\t}, task);\n\n\treturn predecessors;\n};\n\n\ngantt._getDependencies = function(task){\n\tvar successors = this._getSuccessors(task).concat(\n\t\tthis._getSummaryPredecessors(task)\n\t);\n\treturn successors;\n};\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// dhtmlxgantt_critical_path.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c4a39cba6e1e70e8474e","module.exports = function(gantt) {\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\t\tvar role = getTarget ? \"target\" : \"source\";\n\t\tgantt.assert(task, \"Link \" + role + \" not found. Task id=\" + taskId + \", link id=\" + link.id);\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\n\tgantt._formatLink = function (link) {\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))) {\n\t\t\treturn relations;\n\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t});\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0; i < from.length; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0; j < to.length; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target));\n\t\t\t}\n\t\t}\n\n\t\treturn relations;\n\t};\n\ngantt._isAutoSchedulable = function(task){\n\treturn task.auto_scheduling !== false;\n};\n\ngantt._getImplicitLinks = function(link, parent, selectOffset){\n\tvar relations = [];\n\tif(this.isSummaryTask(parent)){\n\t\tthis.eachTask(function(c){\n\t\t\tif(!this.isSummaryTask(c))\n\t\t\t\trelations.push({task: c.id, lag: selectOffset(c)});\n\t\t}, parent.id);\n\t}else{\n\t\trelations.push({task:parent.id, lag: 0});\n\t}\n\n\t\treturn relations;\n\t};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\tfor(var i = 0; i < linksIds.length; i++){\n\t\tvar link = this.getLink(linksIds[i]);\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\tvar target = this.getTask(link.target);\n\t\t\tif(this._isAutoSchedulable(target)){\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t}\n\t\t}\n\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\t\tvar successors = [];\n\tvar stop = false;\n\tvar inheritedRelations = [];\n\tif(this.isTaskExists(task.id)){\n\t\tthis.eachParent(function(parent){\n\t\t\tif(stop)\n\t\t\t\treturn;\n\n\t\t\tif(this.isSummaryTask(parent)){\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\n\t\t\t\t\tstop = true;\n\t\t\t\t}else{\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, this._getDirectDependencies(parent, selectSuccessors));\n\t\t\t\t}\n\t\t\t}\n\t\t}, task.id, this);\n\n\t\t\tfor (var i = 0; i < inheritedRelations.length; i++) {\n\n\t\t\t\tvar relProperty = selectSuccessors ? inheritedRelations[i].source : inheritedRelations[i].target;\n\n\t\t\t\tif (relProperty == task.id) {\n\t\t\t\t\tsuccessors.push(inheritedRelations[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\n\tgantt._getSuccessors = function (task) {\n\t\treturn this._getDirectSuccessors(task).concat(this._getInheritedSuccessors(task));\n\t};\n\n\tgantt._getPredecessors = function (task) {\n\t\treturn this._getDirectPredecessors(task).concat(this._getInheritedPredecessors(task));\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\treturn res;\n\t};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/core/links_common.js\n// module id = 1\n// module chunks = 1 3","require(\"../core/links_common\")(gantt);\n\ngantt.config.highlight_critical_path = false;\ngantt._criticalPathHandler = function(){\n\tif(gantt.config.highlight_critical_path)\n\t\tgantt.render();\n};\ngantt.attachEvent(\"onAfterLinkAdd\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterLinkUpdate\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterLinkDelete\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterTaskAdd\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterTaskUpdate\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterTaskDelete\", gantt._criticalPathHandler);\n\n\ngantt._isCriticalTask = function(task, chain){\n\tif(!task || !task.id) return;\n\tvar path = chain || {};\n\n\tif(this._isProjectEnd(task)){\n\t\treturn true;\n\t}else{\n\t\tpath[task.id] = true;\n\t\tvar successors = this._getDependencies(task);\n\t\tfor(var i=0; i < successors.length; i++){\n\t\t\tvar next = this.getTask(successors[i].target);\n\t\t\tif(this._getSlack(task, next, successors[i]) <= 0 && (!path[next.id] && this._isCriticalTask(next, path)))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\ngantt.isCriticalTask = function (task) {\n\tgantt.assert(!!(task && task.id !== undefined), \"Invalid argument for gantt.isCriticalTask\");\n\treturn this._isCriticalTask(task, {});\n};\n\ngantt.isCriticalLink = function (link) {\n\treturn this.isCriticalTask(gantt.getTask(link.source));\n};\n\ngantt.getSlack = function(task1, task2){\n\tvar relations = [];\n\tvar common = {};\n\tfor(var i=0; i < task1.$source.length; i++){\n\t\tcommon[task1.$source[i]] = true;\n\t}\n\tfor(var i=0; i < task2.$target.length; i++){\n\t\tif(common[task2.$target[i]])\n\t\t\trelations.push(task2.$target[i]);\n\t}\n\n\tvar slacks = [];\n\tfor(var i=0; i < relations.length; i++){\n\t\tvar link = this.getLink(relations[i]);\n\t\tslacks.push(this._getSlack(task1, task2, this._convertToFinishToStartLink(link.id, link, task1, task2)));\n\t}\n\n\treturn Math.min.apply(Math, slacks);\n};\n\ngantt._getSlack = function (task, next_task, relation) {\n\t// relation - link expressed as finish-to-start (gantt._convertToFinishToStartLink)\n\tvar types = this.config.types;\n\n\tvar from = null;\n\tif(this.getTaskType(task.type) == types.milestone){\n\t\tfrom = task.start_date;\n\t}else{\n\t\tfrom = task.end_date;\n\t}\n\n\tvar to = next_task.start_date;\n\n\tvar duration = 0;\n\tif(+from > +to){\n\t\tduration = -this.calculateDuration({start_date: to, end_date: from, task: task});\n\t}else{\n\t\tduration = this.calculateDuration({start_date: from, end_date: to, task: task});\n\t}\n\n\tvar lag = relation.lag;\n\tif(lag && lag*1 == lag){\n\t\tduration -= lag;\n\t}\n\n\treturn duration;\n};\n\ngantt._getProjectEnd = function () {\n\tvar tasks = gantt.getTaskByTime();\n\ttasks = tasks.sort(function (a, b) { return +a.end_date > +b.end_date ? 1 : -1; });\n\treturn tasks.length ? tasks[tasks.length - 1].end_date : null;\n};\n\ngantt._isProjectEnd = function (task) {\n\treturn !(this._hasDuration({start_date:task.end_date, end_date: this._getProjectEnd(), task:task}));\n};\n\ngantt._getSummaryPredecessors = function(task){\n\tvar predecessors = [];\n\n\t// all constraints that are applied to summary parents must be applied to the task\n\tthis.eachParent(function(parent){\n\t\tif(this.isSummaryTask(parent))\n\t\t\tpredecessors = predecessors.concat(gantt._getDependencies(parent));\n\t}, task);\n\n\treturn predecessors;\n};\n\n\ngantt._getDependencies = function(task){\n\tvar successors = this._getSuccessors(task).concat(\n\t\tthis._getSummaryPredecessors(task)\n\t);\n\treturn successors;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/ext/critical_path.js\n// module id = 6\n// module chunks = 3"],"sourceRoot":""}